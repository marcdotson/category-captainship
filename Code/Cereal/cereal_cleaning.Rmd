---
title: "Cereal Data Cleaning"
output: github_document
---

Note: This document contains all the code used to merge and clean data for the cereal category. 

Install library.
```{r eval=FALSE, include=FALSE}
#install.packages("tidyverse")
```

Load library.
```{r}
library(plyr)
library(tidyverse)
library(lubridate)
library(readxl)
library(foreach)
```

Create vector of file path names `cereal_files`. Untar (unzip) the `.tgz` file. Use loop to read in 2011 movement
files and bind them together. 
```{r}
#cereal_files <- untar('Cereal_RTE_20102012.tgz', list = TRUE)
untar('Cereal_RTE_20102012.tgz')
move_11 <- read_tsv('nielsen_extracts/RMS/2011/Movement_Files/1005_2011/1344_2011.tsv')
stores_11 <- read_tsv('nielsen_extracts/RMS/2011/Annual_Files/stores_2011.tsv')
rms_11 <- read_tsv('nielsen_extracts/RMS/2010/Annual_Files/rms_versions_2010.tsv')
products <- read_tsv('nielsen_extracts/RMS/Master_Files/Latest/products.tsv', quote = '')
```

Create `full_11` by joining the 2011 stores file to the movement file on `store_code_uc`. Then filter for `F` (food)
and `ND` (North Dakota) `MN` (Minnesota) `MO` (Missouri) and `IL` (Illinois). Join the 2011 rms file to the movement
file on `upc`, then join the products file to the movement file on `upc` and `upc_ver_uc`. This ensures that no
entries in the movement file are duplicated.
```{r}
full_11 <- move_11 %>%
  left_join(stores_11, by = 'store_code_uc') %>% 
  filter(channel_code == 'F' & fips_state_descr %in% c('ND', 'MN', 'MO', 'IL')) %>%
  left_join(rms_11, by = 'upc') %>%
  left_join(products, by = c('upc', 'upc_ver_uc'))

rm(move_11, rms_11, stores_11)
```

Read in files for 2012 the same way as for 2011, and create `full_12` the same way as `full_11`.
```{r}
move_12 <- read_tsv('nielsen_extracts/RMS/2012/Movement_Files/1005_2012/1344_2012.tsv')
stores_12 <- read_tsv('nielsen_extracts/RMS/2012/Annual_Files/stores_2012.tsv')
rms_12 <- read_tsv('nielsen_extracts/RMS/2012/Annual_Files/rms_versions_2012.tsv')

full_12 <- move_12 %>%
  left_join(stores_12, by = 'store_code_uc') %>% 
  filter(channel_code == 'F' & fips_state_descr %in% c('ND', 'MN', 'MO', 'IL')) %>%
  left_join(rms_12, by = 'upc') %>%
  left_join(products, by = c('upc', 'upc_ver_uc'))

rm(move_12, stores_12, rms_12, products)
```

Read in file containing the manufacturer upc prefixes. The captain and validator for cereal are General Mills and
Kellogg's, respectively. Create separate vectors with the upc prefixes for both General Mills and Kellogg's called
`gm_prefs` and `kel_prefs`.
```{r}
prefixes <- read_xlsx('Manufacturer UPC Prefixes - From GS1 Company Database.xlsx')

gm_prefs <- prefixes %>%
  filter(manufacturer == 'General Mills') %>%
  select(prefix) %>%
  pull()

kel_prefs <- prefixes %>%
  filter(manufacturer == "Kellogg's") %>%
  select(prefix) %>%
  pull()
```

Create `full_cereal` by combining the data for 2011 and 2012. Convert `week_end` to be a date variable and create a
numeric version called `n_week_end` which is needed for microsynth. Create `sales` by multiplying `units` and `price`.
Create `manufacturer` by assinging the correct manufacturer based on upc prefixes. We assign General Mills, Kellogg's,
Private Label, and upcs belonging to any other manufacturers fall under 'other'.
```{r}
full_cereal <- full_11 %>%
  bind_rows(full_12) %>%
  mutate(week_end = ymd(week_end),
         sales = units * price,
         manufacturer = if_else(grepl(paste(gm_prefs, collapse = '|'), upc), 'General Mills',
                        if_else(grepl(paste(kel_prefs, collapse = '|'), upc), "Kellogg's",
                        if_else(brand_descr == 'CTL BR', 'Private Label', 'Other', missing = 'Other'))))

rm(full_11, full_12, prefixes)
```

Create `missing_stores` vector which contains the store codes that don't show up in all years in the data. First,
get each distinct combination of `store_code_uc` and `panel_year`, then summarize by counting the number of years
for each store, filter for the `store_code_uc` that have less than two years, and store those codes in the vector
`missing_stores`.
```{r}
missing_stores <- full_cereal %>%
  distinct(store_code_uc, panel_year) %>%
  group_by(store_code_uc) %>%
  summarize(n_years = n()) %>%
  filter(n_years < 2) %>%
  select(store_code_uc) %>%
  pull()
```

Create a vector that contains the `store_code_uc` codes that are assigned to multiple retailer codes. First, generate
unique conbinations of `store_code_uc` and `retailer_code`, then group by `store_code_uc` and count the number of
observations - this is the number of `retailer_code` values for the given `store_code_uc`. Then, filter for the 
`store_code_uc` that have more than one retailer code and pull them into a vector.
```{r}
retailer_switchers <- full_cereal %>%
  distinct(store_code_uc, retailer_code) %>%
  group_by(store_code_uc) %>%
  summarize(n_rets = n()) %>%
  filter(n_rets > 1) %>%
  select(store_code_uc) %>%
  pull()
```

Using a similar approach as the previous chunk explains, create a tbl that contains the `store_code_uc` that have
multiple `parent_code` values.
```{r}
parent_switchers <- full_cereal %>%
  distinct(store_code_uc, parent_code) %>%
  group_by(store_code_uc) %>%
  summarize(n_parent = n()) %>%
  filter(n_parent > 1) %>%
  select(store_code_uc) %>%
  pull()
```

Filter for the store codes that do not switch retailer or parent codes and are not missing from one of the years.
Replace missing `retailer_code` values with the `parent_code`.
```{r}
full_cereal <- full_cereal %>%
  filter(!store_code_uc %in% unique(c(parent_switchers, retailer_switchers, missing_stores))) %>%
  mutate(retailer_code = if_else(is.na(retailer_code), parent_code, retailer_code))

rm(parent_switchers, retailer_switchers, missing_stores)
```

**************************** need to figure out how to do this for the `full_cereal` data.

Create a `stores` vector that contains the unique store codes in the `full_cereal` dataset. Create `full_weeks` vector
which contains every unique `week_end` in the data. Write a loop that goes along each store and upc adding zeros for
sales for every missing `week_end` value for every upc in every store. Bind those missing upc dates and sales back
into the main data `full_cereal`.
```{r}
stores <- unique(full_cereal$store_code_uc)

full_weeks <- full_cereal %>% distinct(week_end) 

for(i in seq_along(stores)) {
  
  partial_upc <- full_cereal %>% 
    filter(store_code_uc == stores[i]) %>% 
    distinct(upc, week_end) %>% 
    group_by(upc) %>%
    summarise(n_weeks = n()) %>% 
    filter(n_weeks < length(full_weeks$week_end)) %>% 
    select(upc) %>% 
    pull()
  
  for(j in seq_along(partial_upc)) {
    
    single_upc <- full_cereal %>% 
      filter(store_code_uc == stores[i] & 
             upc == partial_upc[j])
    
    manuf <- unique(single_upc$manufacturer)
    
    missing_weeks <- full_weeks %>% 
      anti_join(single_upc, by = "week_end") %>% 
      mutate(sales = 0,
             store_code_uc = stores[i],
             upc = partial_upc[j], 
             manufacturer = manuf)
    
    full_cereal <- full_cereal %>% 
      bind_rows(missing_weeks)
    
  }
}
```


```{r}
stores <- unique(full_cereal$store_code_uc)

full_weeks <- full_cereal %>% distinct(week_end) 

for (store in seq_along(stores)) {
  
  single_store <- full_cereal %>%
    filter(store_code_uc == stores[store])
  
  store_missing_upcs <- single_store %>%
    group_by(upc) %>%
    summarize(n_weeks = n()) %>%
    filter(n_weeks < 105) %>%
    select(upc) %>%
    pull()
  
  for (upcode in seq_along(store_missing_upcs)) {
    
    single_upc <- single_store %>%
      filter(upc == store_missing_upcs[upcode])
    
    vars_vec <- single_upc[1,]

    missing_weeks <- full_weeks %>%
      anti_join(single_upc, by = 'week_end') %>%
      pull()

    missing_data <- matrix(nrow = length(missing_weeks),
                       ncol = length(vars_vec)
                       )

    missing_data <- map_df(1:length(missing_weeks), function(x) missing_data[x,] <- vars_vec)

    missing_data['week_end'] <- missing_weeks
    
    missing_data['price'] <- NA

    missing_data[c('units', 'sales')] <- 0
    
    full_cereal <- full_cereal %>%
      bind_rows(missing_data)
    
  }
}  
```

```{r}
full_cereal %>%
  filter(store_code_uc == 406465) %>%
  group_by(upc) %>%
  summarize(n_weeks = n()) %>%
  filter(n_weeks < 105) %>%
  select(upc) %>%
  pull()
```
-------------------------------------------------------------------------------
```{r}
full_weeks <- full_cereal %>% distinct(week_end) 

temp <- full_cereal %>%
  ddply(.(store_code_uc, upc), .fun = function(x) {
    
    vars_vec <- x[1,]

    missing_weeks <- full_weeks %>%
      anti_join(x, by = 'week_end') %>%
      pull()

    missing_data <- matrix(nrow = length(missing_weeks),
                           ncol = length(vars_vec)
                           )

    missing_data <- map_df(1:length(missing_weeks), function(y) missing_data[y,] <- vars_vec)

    #missing_data['week_end'] <- missing_weeks
    
    #missing_data['price'] <- NA

    #missing_data[c('units', 'sales')] <- 0
    
    #x <- x %>%
    #  bind_rows(missing_data)
    
  })
```

Create `multi_brand_descr` which contains the upc codes that have multiple brand descriptions. We assume that upc codes
with one valid brand description and an `NA` value as the other description actually have the same description and are
the same product. Create `non_na_descr` which contains the upc codes that have multiple brand descriptions that don't
include an `NA` value. Filter `full_cereal` for the upc codes that have multiple valid brand descriptions and compare
them to see if the upc code was used for different products belonging to different manufacturers. All the upc codes in
this category that had multiple brand descriptions were the same product, they just had a slight change in how the
`brand_descr` was entered.
```{r}
multi_brand_descr <- full_cereal %>%
  distinct(upc, brand_descr) %>%
  group_by(upc) %>%
  summarize(n = n()) %>%
  filter(n > 1) %>%
  select(upc) %>%
  pull()

non_na_descr <- full_cereal %>%
  filter(upc %in% multi_brand_descr) %>%
  distinct(upc, brand_descr) %>%
  arrange(upc) %>%
  filter(!is.na(brand_descr)) %>%
  group_by(upc) %>%
  summarize(n = n()) %>%
  filter(n > 1) %>%
  select(upc) %>%
  pull()

full_cereal %>%
  filter(upc %in% non_na_descr) %>%
  distinct(upc, brand_descr) %>%
  arrange(upc)
```

Check if there are private label products with `NA` brand description values, which we should change to `'CTL BR'` so that they are aggregated under the correct manufacturer. Change `NA` brand descriptions for private label products.
```{r}
full_cereal %>%
  filter(upc %in% multi_brand_descr) %>%
  distinct(upc, brand_descr) %>%
  arrange(upc)

full_cereal <- full_cereal %>%
  mutate(brand_descr = if_else(upc %in% priv_lab_na, 'CTL BR', brand_descr),
         n_week_end = as.numeric(week_end))
```

Save the cleaned data and save files for each state. 
```{r}
save(full_cereal, file = 'cereal_clean.RData')

mn_cereal <- full_cereal %>% filter(fips_state_descr == 'MN')
il_cereal <- full_cereal %>% filter(fips_state_descr == 'IL')
mo_cereal <- full_cereal %>% filter(fips_state_descr == 'MO')
nd_cereal <- full_cereal %>% filter(fips_state_descr == 'ND')

save(mn_cereal, file="mn_cereal_clean.RData")
save(il_cereal, file="il_cereal_clean.RData")
save(mo_cereal, file="mo_cereal_clean.RData")
save(nd_cereal, file="nd_cereal_clean.RData")
```